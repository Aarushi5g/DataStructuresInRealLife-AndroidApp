package com.droideri.datastructuresinreallifenew;

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.widget.ExpandableListAdapter;
import android.widget.ExpandableListView;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class Vocab extends AppCompatActivity {

    ExpandableListView expandableListView;
    List<String> words;
    Map<String, String> definations;
    ExpandableListAdapter listAdapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_vocab);

        Objects.requireNonNull(getSupportActionBar()).setTitle("Data Structures Vocabulary");
        getSupportActionBar().setDisplayHomeAsUpEnabled(true);

        expandableListView = (ExpandableListView) findViewById(R.id.expandableListView);
        fillData();

        listAdapter = new MyExListAdapter(this, words, definations);
        expandableListView.setAdapter(listAdapter);

        expandableListView.setOnGroupExpandListener(new ExpandableListView.OnGroupExpandListener() {
            int previousGroup = -1;
            @Override
            public void onGroupExpand(int groupPosition) {
                if(groupPosition != previousGroup)
                    expandableListView.collapseGroup(previousGroup);
                previousGroup = groupPosition;
            }
        });
    }

    public void fillData(){
        words = new ArrayList<>();
        definations = new LinkedHashMap<>();

        words.add("2-3 tree");
        words.add("abstract data type");
        words.add("address");
        words.add("adjacency list");
        words.add("adjacency matrix");
        words.add("adjacent");
        words.add("algorithm");
        words.add("ancestor");
        words.add("array");
        words.add("array-based list");
        words.add("array-based queue");
        words.add("array-based stack");
        words.add("ASCII");
        words.add("association list");
        words.add("asymptotic analysis");
        words.add("attribute");
        words.add("automatic variable");
        words.add("average case");
        words.add("average seek time");
        words.add("AVL Tree");
        words.add("B∗-tree");
        words.add("B+-tree");
        words.add("B-tree");
        words.add("backtracking");
        words.add("balanced tree");
        words.add("base case");
        words.add("basic operation");
        words.add("best case");
        words.add("BFS");
        words.add("big-Oh notation");
        words.add("binary search");
        words.add("binary search tree");
        words.add("binary tree");
        words.add("binary trie");
        words.add("binding");
        words.add("binding list");
        words.add("breadth-first search");
        words.add("brute force approach");
        words.add("bubble sort");
        words.add("bucket hashing");
        words.add("bucket sort");
        words.add("buffering");
        words.add("caching");
        words.add("call stack");
        words.add("child");
        words.add("circular list");
        words.add("clique");
        words.add("closed hash system");
        words.add("code generation");
        words.add("code optimization");
        words.add("collision");
        words.add("comparison");
        words.add("compiler");
        words.add("complete binary tree");
        words.add("complete graph");
        words.add("computability");
        words.add("connected graph");
        words.add("constant running time");
        words.add("container class");
        words.add("cost");
        words.add("cycle");
        words.add("data item");
        words.add("data structure");
        words.add("data type");
        words.add("deallocation");
        words.add("decision problem");
        words.add("decision tree");
        words.add("degree");
        words.add("dense graph");
        words.add("depth");
        words.add("depth-first search");
        words.add("dequeue");
        words.add("dereference");
        words.add("descendant");
        words.add("deterministic algorithm");
        words.add("Dijkstra's algorithm");
        words.add("directed acyclic graph");
        words.add("directed edge");
        words.add("directed graph");
        words.add("disjoint");
        words.add("divide and conquer");
        words.add("double hashing");
        words.add("double rotation");
        words.add("doubly linked list");
        words.add("dynamic");
        words.add("dynamic allocation");
        words.add("dynamic array");
        words.add("dynamic programming");
        words.add("edge");
        words.add("efficient");
        words.add("element");
        words.add("enqueue");
        words.add("enumeration");
        words.add("exceptions");
        words.add("exchange sort");
        words.add("external sort");
        words.add("factorial");
        words.add("FIFO");
        words.add("Floyd's algorithm");
        words.add("Ford and Johnson sort");
        words.add("free tree");
        words.add("full binary tree theorem");
        words.add("full tree");
        words.add("function");
        words.add("garbage");
        words.add("general tree");
        words.add("graph");
        words.add("greedy algorithm");
        words.add("growth rate");
        words.add("guided traversal");
        words.add("hard algorithm");
        words.add("hash function");
        words.add("hash table");
        words.add("hashing");
        words.add("head");
        words.add("header node");
        words.add("heap");
        words.add("heapsort");
        words.add("height");
        words.add("height balanced");
        words.add("Huffman coding tree");
        words.add("in degree");
        words.add("incident");
        words.add("indexing");
        words.add("inode");
        words.add("inorder traversal");
        words.add("Insertion Sort");
        words.add("internal node");
        words.add("internal sort");
        words.add("job");
        words.add("jump search");
        words.add("K-ary tree");
        words.add("k-path");
        words.add("key");
        words.add("key sort");
        words.add("Kruskal's algorithm");
        words.add("labeled graph");
        words.add("leaf node");
        words.add("level");
        words.add("lexical analysis");
        words.add("LIFO");
        words.add("linear probing");
        words.add("linear search");
        words.add("link node");
        words.add("linked list");
        words.add("linked stack");
        words.add("list");
        words.add("mapping");
        words.add("mark array");
        words.add("max heap");
        words.add("Mergesort");
        words.add("mid-square method");
        words.add("min heap");
        words.add("minimal-cost spanning tree");
        words.add("neighbor");
        words.add("node");
        words.add("open hash system");
        words.add("out degree");
        words.add("overflow");
        words.add("overhead");
        words.add("parent");
        words.add("partition");
        words.add("path");
        words.add("pivot");
        words.add("pop");
        words.add("preorder traversal");
        words.add("Prim's algorithm");
        words.add("primary clustering");
        words.add("priority");
        words.add("priority queue");
        words.add("program");
        words.add("push");
        words.add("quadratic probing");
        words.add("quadtree");
        words.add("queue");
        words.add("Quicksort");
        words.add("radix sort");
        words.add("recursion");
        words.add("recursive data structure");
        words.add("Red-Black Tree");
        words.add("reference");
        words.add("root");
        words.add("rotation");
        words.add("runtime stack");
        words.add("search tree");
        words.add("searching");
        words.add("selection sort");
        words.add("separate chaining");
        words.add("sequential search");
        words.add("Shellsort");
        words.add("shortest path");
        words.add("sibling");
        words.add("simple cycle");
        words.add("simple path");
        words.add("singly linked list");
        words.add("skip list");
        words.add("sorted list");
        words.add("sparse graph");
        words.add("spatial data structure");
        words.add("Splay Tree");
        words.add("stack");
        words.add("Strassen's algorithm");
        words.add("subgraph");
        words.add("subtree");
        words.add("tail");
        words.add("Theta notation");
        words.add("total path length");
        words.add("Towers of Hanoi problem");
        words.add("traversal");
        words.add("tree");
        words.add("trie");
        words.add("underflow");
        words.add("undirected edge");
        words.add("undirected graph");
        words.add("unsorted list");
        words.add("unsuccessful search");
        words.add("unvisited");
        words.add("vertex");
        words.add("visited");
        words.add("weight");
        words.add("weighted graph");
        words.add("worst case");


        definations.put(words.get(0), "A form of B-tree where each internal node has either 2 children or 3 children. The 2-3 tree is always height balanced, and its insert, search, and remove operations all have Θ(logn) cost.");
        definations.put(words.get(1), "A description of operations on a data type that could have multiple possible implementations. The behavior of each operation is determined by its inputs and outputs.");
        definations.put(words.get(2), "A location in memory.");
        definations.put(words.get(3), "An implementation for a graph that uses an (array-based) list to represent the vertices of the graph, and each vertex is in turn represented by a (linked) list of the vertices that are neighbors.");
        definations.put(words.get(4), "An implementation of a graph in which a boolean matrix contains a 1 at position  (i, j) iff there is an link from node i to node j, otherwise 0.");
        definations.put(words.get(5), "Two nodes of a tree or two vertices of a graph are said to be adjacent if they have an edge connecting them. If the edge is directed from a to b, then we say that a is adjacent to b, and b is adjacent from a.");
        definations.put(words.get(6), "A method or a process followed to solve a problem.");
        definations.put(words.get(7), "In a tree, for a given node A, any node on a path from A up to the root is an ancestor of A.");
        definations.put(words.get(8), "A contiguous block of memory containing elements of the same type, accessed by numeric index.");
        definations.put(words.get(9), "An implementation for the list ADT (abstract data type) that uses an array to store the list elements.");
        definations.put(words.get(10), "Analogous to an array-based list, this uses an array to store the elements when implementing the queue ADT.");
        definations.put(words.get(11), "Analogous to an array-based list, this uses an array to store the elements when implementing the stack ADT.");
        definations.put(words.get(12), "American Standard Code for Information Interchange. A commonly used method for encoding characters using a binary code. Standard ASCII uses an 8-bit code to represent upper and lower case letters, digits, some punctuation, and some number of non-printing characters. Now largely replaced by UTF-8 encoding.");
        definations.put(words.get(13), "A list of pairs, where each pair has a key and a value associated with the key.");
        definations.put(words.get(14), "A method for estimating the efficiency of an algorithm by identifying its growth rate. We frequently use the term algorithm analysis in place of asymptotic analysis.");
        definations.put(words.get(15), "A specification that defines a property of an object, element, or file. An attribute is frequently and generally a property of a property.");
        definations.put(words.get(16), "A synonym for local variable. When program flow enters and leaves the variable's scope, automatic variables will be allocated and de-allocated automatically.");
        definations.put(words.get(17), "In algorithm analysis, the average of the costs for all problem instances of a given input size n. If not all problem instances have equal probability of occurring, then average case must be calculated using a weighted average.");
        definations.put(words.get(18), "Expected (average) time to perform a seek operation on a disk drive.");
        definations.put(words.get(19), "A self-balancing sorted binary tree, in which the heights of subtrees differ by at most 1. It uses modified insert and remove methods in order to keep the tree balanced.");
        definations.put(words.get(20), "A variant on the B+-tree. The B∗ tree is identical to the B+ tree, except for the rules used to split and merge nodes. Instead of splitting a node in half when it overflows, the B∗ tree gives some records to its neighboring sibling, if possible. If the sibling is also full, then these two nodes split into three. Similarly, when a node underflows, it is combined with its two siblings, and the total reduced to two nodes. Thus, the nodes are always at least two thirds full.");
        definations.put(words.get(21), "The most commonly implemented form of B-tree. A B+-tree does not store data at the internal nodes, but instead only stores search key values as direction finders for the purpose of searching through the tree. Only the leaf nodes store a reference to the actual data records.");
        definations.put(words.get(22), "A balanced tree with a high branching factor (commonly as much as 100 children per internal node), to minimize the number of disk accesses required to access a desired record. The most commonly implemented variant of the B-tree is the B+-tree.");
        definations.put(words.get(23), "A problem-solving algorithm that uses a brute force approach for finding the desired output. In a tree search, moving back from the node currently being examined to its parent.");
        definations.put(words.get(24), "A tree in which the heights of subtrees are approximately equal.");
        definations.put(words.get(25), "A simple case that can be solved easily, without recursion.");
        definations.put(words.get(26), "Examples of basic operations include inserting a data item into the data structure, deleting a data item from the data structure, and finding a specified data item.");
        definations.put(words.get(27), "In algorithm analysis, the problem instance from among all problem instances for a given input size n that has least cost.");
        definations.put(words.get(28), "Abbreviation for breadth-first search.");
        definations.put(words.get(29),  "A function that describes the amount of computer time or memory space required by an algorithm, as a function of problem size.");
        definations.put(words.get(30), "A standard recursive algorithm for finding the record with a given search key value within a sorted list. It runs in O(logn) time. At each step, look at the middle of the current sublist, and throw away the half of the records whose keys are either too small or too large.");
        definations.put(words.get(31), "A binary tree that imposes the following constraint on its node values: The search key value for any node A must be greater than the (key) values for all nodes in the left subtree of A, and less than the key values for all nodes in the right subtree of A.");
        definations.put(words.get(32), "A tree in which each node has at most two children.");
        definations.put(words.get(33), "A binary tree whose structure is that of a trie. Generally this is an implementation for a search tree. This means that the search key values are thought of a binary digits, with the digit in the position corresponding to this a node's level in the tree indicating a left branch if it is \"0\", or a right branch if it is \"1\". Examples include the Huffman coding tree and the Bintree.");
        definations.put(words.get(34), "An association of a name with a value.");
        definations.put(words.get(35), "A list structure that represents a set of bindings.");
        definations.put(words.get(36), "A graph traversal algorithm. As the name implies, all immediate neighbors for a node are visited before any more-distant nodes are visited. BFS is driven by a queue. A start vertex is placed on the queue. Then, until the queue is empty, a node is taken off the queue, visited, and and then any unvisited neighbors are placed onto the queue.");
        definations.put(words.get(37), "The Brute force approach tries out all the possible solutions and chooses the desired/best solutions.");
        definations.put(words.get(38), "A simple sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order. It requires O(n^2) time in best, average, and worst cases.");
        definations.put(words.get(39), "A method of hashing where multiple slots of the hash table are grouped together to form a bucket. The hash function then hashes the values to the buckets. Collision resolution is handled first by attempting to find a free position within the same bucket. If the bucket if full, then the record is placed in an overflow bucket.");
        definations.put(words.get(40), "A sorting technique that sorts the elements by first dividing the elements into several groups called buckets. The elements inside each bucket are sorted using any of the suitable algorithms. Finally, the elements of the bucket are gathered to get the sorted array.");
        definations.put(words.get(41), "A synonym for caching. More specifically, it refers to an arrangement where all accesses to data must be done in multiples of some minimum unit of storage.");
        definations.put(words.get(42), "The concept of keeping selected data in main memory. The goal is to have in main memory the data values that are most likely to be used in the near future.");
        definations.put(words.get(43), "Also known as the execution stack. A stack that stores the function call sequence and the return address for each function.");
        definations.put(words.get(44), "In a tree, the set of nodes directly pointed to by a node R are the children of R.");
        definations.put(words.get(45), "A list ADT implementation variant where the last element of the list provides access to the first element of the list.");
        definations.put(words.get(46), "In graph terminology, a clique is a subgraph, defined as any subset U of the graph's vertices such that every vertex in U has an edge to every other vertex in U. The size of the clique is the number of vertices in the clique.");
        definations.put(words.get(47), "A hash system where all records are stored in slots of the hash table. This is in contrast to an open hash system.");
        definations.put(words.get(48), "Process of turning a parse tree (that determines the correctness of the structure of the program) into actual instructions that the computer can execute.");
        definations.put(words.get(49), "A phase in a compiler that makes changes in the code with the goal of replacing it with a version of the code that will run faster while performing the same computation.");
        definations.put(words.get(50), "In a hash system, this refers to the case where two search keys are mapped by the hash function to the same slot in the hash table. In this case, a closed hash system will require a process known as collision resolution to find the location of the desired record.");
        definations.put(words.get(51), "The act of comparing two values to determine which is greater according to some ordering.");
        definations.put(words.get(52), "Reads computer programs and converts them into a form that can be directly executed. The major phases in a compiler include lexical analysis, syntax analysis, intermediate code generation, code optimization, and code generation.");
        definations.put(words.get(53), "A binary tree where the nodes are filled in row by row, with the bottom row filled in left to right. The heap data structure is a complete binary tree with partial ordering constraints on the node values.");
        definations.put(words.get(54), "A graph where every vertex connects to every other vertex.");
        definations.put(words.get(55), "A branch of computer science that deals with the theory of solving problems through computation. More specifically, it deals with the limits to what problems are computable. An example of a famous problem that cannot in principle be solved by a computer is the halting problem.");
        definations.put(words.get(56), "An undirected graph is a connected graph if there is at least one path from any vertex to any other.");
        definations.put(words.get(57), "The cost of a function whose running time is not related to its input size. In Theta notation, this is traditionally written as Θ(1).");
        definations.put(words.get(58), "A data structure that stores a collection of records. Typical examples are arrays, search trees, and hash tables.");
        definations.put(words.get(59), "The amount of resources that the solution consumes.");
        definations.put(words.get(60), "In graph terminology, a cycle is a path of length three or more that connects some vertex v1 to itself.");
        definations.put(words.get(61), "A piece of information or a record whose value is drawn from a type.");
        definations.put(words.get(62), "Set of algorithms that we can use in any programming language to structure the data in the memory.");
        definations.put(words.get(63), "A type together with a collection of operations to manipulate the type.");
        definations.put(words.get(64), "Free the memory allocated to an unused object.");
        definations.put(words.get(65), "A problem whose output is either \"YES\" or \"NO\".");
        definations.put(words.get(66), "A flowchart like tree structure, where each internal node denotes a test on an attribute, each branch represents an outcome of the test, and each leaf node holds a class label.");
        definations.put(words.get(67), "In graph terminology, the degree for a vertex is its number of neighbors. In a directed graph, the in degree is the number of edges directed into the vertex, and the out degree is the number of edges directed out of the vertex. In tree terminology, the degree for a node is its number of children.");
        definations.put(words.get(68), "A graph where the actual number of edges is a large fraction of the possible number of edges. Generally, this is interpreted to mean that the degree for any vertex in the graph is relatively high.");
        definations.put(words.get(69), "The depth of a node M in a tree is the length of the path from the root of the tree to M.");
        definations.put(words.get(70), "A graph traversal algorithm in which children of a node are searched (recursively) before siblings are considered.");
        definations.put(words.get(71), "A specialized term used to indicate removing an element from a queue.");
        definations.put(words.get(72), "To convert from a pointer (address) to the data that is pointed to.");
        definations.put(words.get(73), "In a tree, the set of all nodes that have a node A as an ancestor are the descendants of A. Another way to say it is: The children of A, their children, and so on.");
        definations.put(words.get(74), "An algorithm that does not involve any element of randomness, and so its behavior on a given input will always be the same. This is in contrast to a randomized algorithm.");
        definations.put(words.get(75), "An optimal greedy algorithm to find the minimum distance and shortest path in a weighted graph from a give start node. It is nearly identical to Prim's algorithm for finding a minimal-cost spanning tree, with the only difference being the calculation done to update the best-known distance.");
        definations.put(words.get(76), "A graph with no cycles. Abbreviated as DAG. Note that a DAG is not necessarily a tree since a given node might have multiple parents.");
        definations.put(words.get(77), "An edge that goes from vertex to another. In contrast, an undirected edge simply links to vertices without a direction.");
        definations.put(words.get(78), "A graph whose edges each are directed from one of its defining vertices to the other.");
        definations.put(words.get(79), "Two parts of a data structure or two collections with no objects in common are disjoint. This term is often used in conjunction with a data structure that has nodes (such as a tree).");
        definations.put(words.get(80), "A problem-solving strategy in which a problem is broken down into sub-problems, until simple subproblems are reached. This process is often implemented using recursion.");
        definations.put(words.get(81), "A collision resolution method. A second hash function is used to generate a value c on the key. That value is then used by this key as the step size in linear probing by steps. Since different keys use different step sizes (as generated by the second hash function), this process avoids the clustering caused by standard linear probing.");
        definations.put(words.get(82), "A rotation in which a right rotation is followed by a left rotation. This type of rebalancing operation used by the Splay Tree and AVL Tree.");
        definations.put(words.get(83), "A linked list implementation variant where each list node contains access pointers to both the previous element and the next element on the list.");
        definations.put(words.get(84), "In computer programming, dynamic normally refers to something that happens at run time.");
        definations.put(words.get(85), "The act of creating an object from free store.");
        definations.put(words.get(86), "Arrays, once allocated, are of fixed size. A dynamic array puts an interface around the array so as to appear to allow the array to grow and shrink in size as necessary. Typically this is done by allocating a new copy, copying the contents of the old array, and then returning the old array to free store.");
        definations.put(words.get(87), "An approach to designing algorithms that works by storing a table of results for subproblems. A typical cause for excessive cost in recursive algorithms is that different branches of the recursion might solve the same subproblem. Dynamic programming uses a table to store information about which subproblems have already been solved, and uses the stored information to immediately give the answer for any repeated attempts to solve that subproblem.");
        definations.put(words.get(88), "The connection that links two nodes in a tree, linked list, or graph.");
        definations.put(words.get(89), "A solution is said to be efficient if it solves the problem within the required resource constraints. A solution is sometimes said to be efficient if it requires fewer resources than known alternatives, regardless of whether it meets any particular requirements.");
        definations.put(words.get(90), "One value or member in a set.");
        definations.put(words.get(91), "A specialized term used to indicate inserting an element onto a queue.");
        definations.put(words.get(92), "The process by which a traversal lists every object in the container exactly once. Thus, a traversal that prints the nodes is said to enumerate the nodes.");
        definations.put(words.get(93), "Exceptions are techniques used to predict possible runtime errors and handle them properly.");
        definations.put(words.get(94), "A sort that relies solely on exchanges (swaps of adjacent records) to reorder the list. Insertion Sort and Bubble Sort are examples of exchange sorts. All exchange sorts require Θ(n^2) time in the worst case.");
        definations.put(words.get(95), "A sorting algorithm that is applied to data stored in peripheral storage such as on a disk drive. This is in contrast to an internal sort that works on data stored in main memory.");
        definations.put(words.get(96), "A quantity defined for all integer s greater than or equal to 0. For an integer n greater than or equal to 1, the factorial is the product of all integers less than or equal to n but greater than or equal to 1. The factorial value of 0 is defined as equal to 1.");
        definations.put(words.get(97), "Abbreviation for \"first-in, first-out\". This is the access paradigm for a queue, and an old terminology for the queue is \"FIFO list\".");
        definations.put(words.get(98), "An algorithm to solve the all-pairs shortest paths problem. It uses the dynamic programming algorithmic technique, and runs in Θ(n^3) time. The basic idea is to first find all the direct edge costs, then improving those costs by allowing paths through vertex 0, then the cheapest paths involving paths going through vertices 0 and 1, and so on.");
        definations.put(words.get(99), "A sorting algorithm that is close to the theoretical minimum number of key comparisons necessary to sort. It consists of first sorting pairs of nodes into winners and losers (of the pairs comparisons), then (recursively) sorting the winners of the pairs, and then finally carefully selecting the order in which the losers are added to the chain of sorted items.");
        definations.put(words.get(100), "A connected, undirected graph with no simple cycles. An equivalent definition is that a free tree is connected and has |V|−1 edges.");
        definations.put(words.get(101), "This theorem states that the number of leaves in a non-empty full binary tree is one more than the number of internal nodes. Equivalently, then number of null pointers in a standard pointer-based implementation for binary tree nodes is one more than the number of nodes in the binary tree.");
        definations.put(words.get(102), "A binary tree is full if every node is either a leaf node or else it is an internal node with two non-empty children.");
        definations.put(words.get(103), "In mathematics, a matching between inputs (the domain) and outputs (the range). In programming, a subroutine that takes input parameters and uses them to compute and return a value. In this case, it is usually considered bad practice for a function to change any global variables (doing so is called a side effect).");
        definations.put(words.get(104), "Storage that is no longer pointed to by any variable and therefore can no longer be accessed. In some languages, garbage can be recovered by garbage collection. In languages such as C and C++ that do not support garbage collection, so creating garbage is considered a memory leak.");
        definations.put(words.get(105), "A tree in which any given node can have any number of children. This is in contrast to, for example, a binary tree where each node has a fixed number of children.");
        definations.put(words.get(106), "A graph G=(V,E) consists of a set of vertices V and a set of edges E, such that each edge in E is a connection between a pair of vertices in V.");
        definations.put(words.get(107), "An algorithm that always tries the solution path that appears to be the best.");
        definations.put(words.get(108), "In algorithm analysis, the rate at which the cost of the algorithm grows as the size of its input grows.");
        definations.put(words.get(109), "A tree traversal that does not need to visit every node in the tree. An example would be a range query in a BST.");
        definations.put(words.get(110), "\"Hard\" is traditionally defined in relation to running time, and a \"hard\" algorithm is defined to be an algorithm with exponential running time.");
        definations.put(words.get(111), "In a hash system, the function that converts a key value to a position in the hash table. The hope is that this position in the hash table contains the record that matches the key value.");
        definations.put(words.get(112), "The data structure (usually an array) that stores data records for lookup using hashing.");
        definations.put(words.get(113), "A search method that uses a hash function to convert a search key value into a position within a hash table. In a properly implemented hash system, that position in the table will have high probability of containing the record that matches the key value. Sometimes, the hash function will return an position that does not store the desired key, due to a process called collision. In that case, the desired record is found through a process known as collision resolution.");
        definations.put(words.get(114), "The beginning of a list.");
        definations.put(words.get(115), "Commonly used in implementations for a linked list or related structure, this node preceeds the first element of the list. Its purpose is to simplify the code implementation by reducing the number of special cases that must be programmed for.");
        definations.put(words.get(116), "A complete binary tree with the requirement that every node has a value greater than its children (called a max heap), or else the requirement that every node has a value less than its children (called a min heap).To add a new value to a heap, or to remove the extreme value and update the heap, takes Θ(logn) time in the worst case. However, if given all of the values in an unordered array, the values can be re-arranged to form a heap in only Θ(n) time. Due to its space and time efficiency, the heap is a popular choice for implementing a priority queue.");
        definations.put(words.get(117), "A sorting algorithm that costs Θ(nlogn) time in the best, average, and worst cases. It tends to be slower than Mergesort and Quicksort. It works by building a max heap, and then repeatedly removing the item with maximum key value (moving it to the end of the heap) until all elements have been removed (and replaced at their proper location in the array).");
        definations.put(words.get(118), "The height of a tree is one more than the depth of the deepest node in the tree.");
        definations.put(words.get(119), "The condition the depths of each subtree in a tree are roughly the same.");
        definations.put(words.get(120), "A full binary tree that is used to represent letters (or other symbols) efficiently. Each letter is associated with a node in the tree, and is then given a Huffman code based on the position of the associated node. A Huffman coding tree is an example of a binary trie.");
        definations.put(words.get(121), "In graph terminology, the in degree for a vertex is the number of edges directed into the vertex.");
        definations.put(words.get(122), "In graph terminology, an edge connecting two vertices is said to be incident with those vertices. The two vertices are said to be adjacent.");
        definations.put(words.get(123), "The process of associating a search key with the location of a corresponding data record.");
        definations.put(words.get(124), "Short for \"index node\".");
        definations.put(words.get(125), "In a binary tree, a traversal that first recursively visits the left child, then visits the root, and then recursively visits the right child. In a binary search tree, this traversal will enumerate the nodes in sorted order.\n");
        definations.put(words.get(126), "A sorting algorithm in which we insert each element onto its proper place in the sorted array. With Θ(n^2) average and worst case cost, and Θ(n) best case cost. ");
        definations.put(words.get(127), "In a tree, any node that has at least one non-empty child is an internal node.");
        definations.put(words.get(128), "A sorting algorithm that is applied to data stored in main memory. This is in contrast to an external sort that is meant to work on data stored in peripheral storage such as on a disk drive.");
        definations.put(words.get(129), "Common name for processes or tasks to be run by an operating system. They typically need to be processed in order of importance, and so are kept organized by a priority queue. Another common use for this term is for a collection of tasks to be ordered by a topological sort.");
        definations.put(words.get(130), "An algorithm for searching a sorted list, that falls between sequential search and binary search in both computational cost and conceptual complexity. The idea is to keep jumping by some fixed number of positions until a value is found that is bigger than search key K, then do a sequential search over the subarray that is now known to contain the search key.");
        definations.put(words.get(131), "A type of full tree where every internal node has exactly K children.");
        definations.put(words.get(132), "In Floyd's algorithm, a k-path is a path between two vertices i and j that can only go through vertices with an index value less than or equal to k.");
        definations.put(words.get(133), "A field or part of a larger record used to represent that record for the purpose of searching or comparing. Another term for search key.");
        definations.put(words.get(134), "Any sorting operation applied to a collection of key-value pairs where the value in this case is a reference to a complete record (that is, a pointer to the record in memory or a position for a record on disk). This is in contrast to a sorting operation that works directly on a collection of records. The intention is that the collection of key-value pairs is far smaller than the collection of records themselves. As such, this might allow for an internal sort when sorting the records directly would require an external sort. The collection of key-value pairs can also act as an index.\n");
        definations.put(words.get(135), "An algorithm used to find the minimum spanning tree for a connected weighted graph. The main target of the algorithm is to find the subset of edges by using which, we can traverse every vertex of the graph.");
        definations.put(words.get(136), "A graph with labels associated with the nodes.");
        definations.put(words.get(137), "In a general tree, any node is a leaf node if it has no children.");
        definations.put(words.get(138), "In a tree, all nodes of depth d are at level d in the tree. The root is the only node at level 0, and its depth is 0.");
        definations.put(words.get(139), "A phase of a compiler or interpreter responsible for reading in characters of the program or language and grouping them into tokens.");
        definations.put(words.get(140), "Abbreviation for \"Last-In, First-Out\". This is the access paradigm for a stack, and an old terminolgy for the stack is \"LIFO list\".");
        definations.put(words.get(141), "In hashing, this is the simplest collision resolution method. It works by moving sequentially through the hash table from the home slot. While simple, it is also inefficient, since it quickly leads to certain free slots in the hash table having higher probability of being selected during insertion or search.");
        definations.put(words.get(142), "A sequential search is made over all items one by one. Every item is checked and if a match is found then that particular item is returned, otherwise the search continues till the end of the data collection.");
        definations.put(words.get(143), "A widely used supporting object that forms the basic building block for a linked list and similar data structures. A link node contains one or more fields that store data, and a pointer or reference to another link node.");
        definations.put(words.get(144), "An implementation for the list ADT that uses dynamic allocation of link nodes to store the list elements. Common variants are the singly linked list, doubly linked list and circular list. The overhead required is the pointers in each link node.");
        definations.put(words.get(145), "Analogous to a linked list, this uses dynamic allocation of nodes to store the elements when implementing the stack ADT.");
        definations.put(words.get(146), "A finite, ordered sequence of data items known as elements. This is close to the mathematical concept of a sequence.");
        definations.put(words.get(147), "A function that maps every element of a given set to a unique element of another set; a correspondence.");
        definations.put(words.get(148), "It is typical in graph algorithms that there is a need to track which nodes have been visited at some point in the algorithm. An array of bits or values called the mark array is often maintained for this purpose.");
        definations.put(words.get(149), "A heap where every node has a key value greater than its children. As a consequence, the node with maximum key value is at the root.");
        definations.put(words.get(150), "A sorting algorithm that requires Θ(nlogn) in the best, average, and worst cases. Conceptually it is simple: Split the list in half, sort the halves, then merge them together.");
        definations.put(words.get(151), "In hashing, an approach to implementing a hash function. The key value is squared, and some number of bits from the middle of the resulting value are extracted as the hash code.");
        definations.put(words.get(152), "A heap where every node has a key value less than its children. As a consequence, the node with minimum key value is at the root.");
        definations.put(words.get(153), "Derived from a weighted graph, the MCST is the subset of the graph's edges that maintains the connectivitiy of the graph while having lowest total cost (as defined by the sum of the weights of the edges). The result is referred to as a tree because it would never have a cycle (since an edge could be removed from the cycle and still preserve connectivity). Two algorithms to solve this problem are Prim's algorithm and Kruskal's algorithm.");
        definations.put(words.get(154), "In a graph, a node w is said to be a neighbor of node v if there is an edge from v to w.");
        definations.put(words.get(155), "The objects that make up a linked structure such as a linked list or binary tree. Typically, nodes are allocated using dynamic memory allocation. In graph terminology, the nodes are more commonly called vertices.");
        definations.put(words.get(156), "A hash system where multiple records might be associated with the same slot of a hash table. Typically this is done using a linked list to store the records. This is in contrast to a closed hash system.");
        definations.put(words.get(157), "In graph terminology, the out degree for a vertex is the number of edges directed out of the vertex.");
        definations.put(words.get(158), "The condition where the amount of data stored in an entity has exceeded its capacity.");
        definations.put(words.get(159), "All information stored by a data structure aside from the actual data. For example, the pointer fields in a linked list or BST, or the unused positions in an array-based list.");
        definations.put(words.get(160), "In a tree, the node P that directly links to a node A is the parent of A. A is the child of P.");
        definations.put(words.get(161), "In Quicksort, the process of splitting a list into two sublists, such that one sublist has values less than the pivot value, and the other with values greater than the pivot.");
        definations.put(words.get(162), "In tree or graph terminology, a sequence of vertices v1,v2,...,vn forms a path of length n−1 if there exist edges from vi to vi+1 for 1≤i<n.");
        definations.put(words.get(163), "In Quicksort, the value that is used to split the list into sublists, one with lesser values than the pivot, the other with greater values than the pivot.");
        definations.put(words.get(164), "A specialized term used to indicate removing an element from a stack.");
        definations.put(words.get(165), "In a binary tree, a traversal that first visits the root, then recursively visits the left child, then recursively visits the right child.");
        definations.put(words.get(166), "A greedy algorithm for computing the MCST of a graph. It is nearly identical to Dijkstra's algorithm for solving the single-source shortest paths problem, with the only difference being the calculation done to update the best-known distance.");
        definations.put(words.get(167), "In hashing, the tendency in certain collision resolution methods to create clustering in sections of the hash table. The classic example is linear probing. This tends to happen when a group of keys follow the same probe sequence during collision resolution.");
        definations.put(words.get(168), "A quantity assigned to each of a collection of jobs or tasks that indicate importance for order of processing. For example, in an operating system, there could be a collection of processes (jobs) ready to run. The operating system must select the next task to execute, based on their priorities.");
        definations.put(words.get(169), "An ADT whose primary operations of insert of records, and deletion of the greatest (or, in an alternative implementation, the least) valued record. Most often implemented using the heap data structure. The name comes from a common application where the records being stored represent tasks, with the ordering values based on the priorities of the tasks.");
        definations.put(words.get(170), "An instance, or concrete representation, of an algorithm in some programming language.");
        definations.put(words.get(171), "A specialized term used to indicate inserting an element onto a stack.");
        definations.put(words.get(172), "In hashing, this is a collision resolution method that computes term of the probe sequence using some quadratic equation.");
        definations.put(words.get(173), "A full tree where each internal node has four children. Related to the bintree. The difference is that the quadtree splits all dimensions simultaneously, while the bintree splits one dimension at each level. Thus, to extend the quadtree concept to more dimensions requires a rapid increase in the number of splits.");
        definations.put(words.get(174), "A list-like structure in which elements are inserted only at one end, and removed only from the other one end.");
        definations.put(words.get(175), "A sort that is Θ(nlogn) in the best and average cases, though Θ(n^2) in the worst case. It works by divide and conquer, by selecting a pivot value, splitting the list into parts that are either less than or greater than the pivot, and then sorting the two parts.");
        definations.put(words.get(176), "A sorting algorithm that works by processing records with k digit keys in k passes, where each pass sorts the records according to the current digit. At the end of the process, the records will be sorted. It tends to be much slower than other sorting algorithms like Quicksort or mergesort.");
        definations.put(words.get(177), "When function is called within the same function.");
        definations.put(words.get(178), "A data structure that is partially composed of smaller or simpler instances of the same data structure. For example, linked lists and binary trees can be viewed as recursive data structures.");
        definations.put(words.get(179), "A binary search tree with the following red-black properties: Every node is either red or black. Every null leaf is black. If a node is red, then both its children are black. Every simple path from a node to a descendant leaf contains the same number of black nodes.");
        definations.put(words.get(180), "A value that enables a program to directly access some particular data item.");
        definations.put(words.get(181), "In a tree, the topmost node of the tree. All other nodes in the tree are descendants of the root.");
        definations.put(words.get(182), "In the AVL Tree and Splay Tree, a rotation is a local operation performed on a node, its children, and its grandchildren that can result in reordering their relationship. The goal of performing a rotation is to make the tree more balanced.");
        definations.put(words.get(183), "The place where an activation record is stored when a subroutine is called during a program's runtime.");
        definations.put(words.get(184), "A tree data structure that makes search by key value more efficient. A good search tree implementation will guarentee that insertion, deletion, and search operations are all Θ(logn).");
        definations.put(words.get(185), "Given a search key and some collection of records, searching is a systematic method for locating the record with the given key value.");
        definations.put(words.get(186), "While this sort requires Θ(n^2) time in the best, average, and worst cases, it requires only Θ(n) swap operations. It can be viewed as an optimization on bubble sort, where a swap is deferred until the end of each iteration.");
        definations.put(words.get(187), "A synonym for open hashing, this technique creates a linked list to the slot for which collision occurs. The new key is then inserted in the linked list.");
        definations.put(words.get(188), "The simplest search algorithm: In an array, simply look at the array elements in the order that they appear.");
        definations.put(words.get(189), "A generalization of sorting by exchange or sorting by insertion. The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared. It relies on the best-case cost of insertion sort to improve over Θ(n2) worst case cost.");
        definations.put(words.get(190), "Given a graph with distances or weights on the edges, the shortest path between two nodes is the path with least total distance or weight. Examples of the shortest paths problems are the single-source shortest paths problem and the all-pairs shortest paths problem.");
        definations.put(words.get(191), "In a tree, a sibling of node A is any other node with the same parent as A.");
        definations.put(words.get(192), "In graph terminology, a cycle is simple if its corresponding path is simple, except that the first and last vertices of the cycle are the same.");
        definations.put(words.get(193), "In graph terminology, a path is simple if all vertices on the path are distinct.");
        definations.put(words.get(194), "A linked list implementation variant where each list node contains access an pointer only to the next element in the list.");
        definations.put(words.get(195), "A form of linked list that adds additional links to improve the cost of fundamental operations like insert, delete, and search. It is a probabilistic data structure since it adds the additional links using a probabilistic algorithm.");
        definations.put(words.get(196), "A list where the records stored are arranged so that their key values are in ascending order. If the list uses an array-based list implementation, then it can use binary search for a cost of Θ(logn). But both insertion and deletion will be require Θ(n) time.");
        definations.put(words.get(197), "A graph where the actual number of edges is much less than the possible number of edges. Generally, this is interpreted to mean that the degree for any vertex in the graph is relatively low.");
        definations.put(words.get(198), "A data structure designed to support efficient processing when a spatial attribute is used as the key. In particular, a data structure that supports efficient search by location, or finds all records within a given region in two or more dimensions.");
        definations.put(words.get(199), "A variant implementation for the BST which uses modified insert and remove methods in order to keep the tree balanced.");
        definations.put(words.get(200), "A list-like structure in which elements may be inserted or removed from only one end.");
        definations.put(words.get(201), "A recursive algorithm for matrix multiplication. When multiplying two n×n matrices, this algorithm runs faster than the Θ(n^3) time required by the standard matrix multiplication algorithm. This is achieved by refactoring the sub-matrix multiplication and addition operations so as to need only 7 sub-matrix multiplications instead of 8, at a cost of additional sub-matrix addition operations. Thus, while the asymptotic cost is lower, the constant factor in the growth rate equation is higher. This makes the algorithm inefficient in practice unless the arrays being multiplied are rather large.");
        definations.put(words.get(202), "A subgraph S is formed from graph G by selecting a subset Vs of G's vertices and a subset Es of G's edges such that for every edge e∈E, both vertices of e are in Vs.");
        definations.put(words.get(203), "A subtree is a subset of the nodes of a binary tree that includes some node R of the tree as the subtree root along with all the descendants of R.");
        definations.put(words.get(204), "The end of a list.");
        definations.put(words.get(205), "Θ notation is used to indicate the upper and the lower bound of the running time of an algorithm. It is used for analyzing the average-case complexity of an algorithm.");
        definations.put(words.get(206), "In a tree, the sum of the levels for each node.");
        definations.put(words.get(207), "A standard example of a recursive algorithm. The problem starts with a stack of disks (each with unique size) stacked decreasing order on the left pole, and two additional poles. The problem is to move the disks to the right pole, with the constraints that only one disk can be moved at a time and a disk may never be on top of a smaller disk. For n disks, this problem requires Θ(2n) moves. The standard solution is to move n−1 disks to the middle pole, move the bottom disk to the right pole, and then move the n−1 disks on the middle pole to the right pole.");
        definations.put(words.get(208), "Any process for visiting all of the objects in a collection (such as a tree or graph) in some order.");
        definations.put(words.get(209), "A widely used abstract data type that simulates a hierarchical tree structure, with a root value and subtrees of children with a parent node, represented as a set of linked nodes.");
        definations.put(words.get(210), "A trie is a tree-like data structure whose nodes store the letters of an alphabet. By structuring the nodes in a particular way, words and strings can be retrieved from the structure by traversing down a branch path of the tree.");
        definations.put(words.get(211), "The condition where the amount of data stored in an entity has dropped below some minimum threshold. For example, a node in a B-tree is required to be at least half full. If a record deletion causes the node to be less than half full, then it is in a condition of underflow, and something has to be done to correct this.");
        definations.put(words.get(212), "An edge that connects two vertices with no direction between them. Many graph representations will represent such an edge with two directed edges.");
        definations.put(words.get(213), "A graph whose edges do not have a direction.");
        definations.put(words.get(214), "A list where the records stored in the list can appear in any order (as opposed to a sorted list). An unsorted list can support efficient Θ(1) insertion time, but requires Θ(n) time for both search and and deletion.");
        definations.put(words.get(215), "When searching for a key value in a collection of records, we might not find it. If so, we call this an unsuccessful search. The alternative to an unsuccessful search is a successful search.");
        definations.put(words.get(216), "In graph algorithms, this refers to a node that has not been processed at the current point in the algorithm. This information is typically maintained by using a mark array.");
        definations.put(words.get(217), "Another name for a node in a graph.");
        definations.put(words.get(218), "In graph algorithms, this refers to a node that has previously been processed at the current point in the algorithm. This information is typically maintained by using a mark array.");
        definations.put(words.get(219), "A cost or distance most often associated with an edge in a graph.");
        definations.put(words.get(220), "A graph whose edges each have an associated weight or cost.");
        definations.put(words.get(221), "In algorithm analysis, the problem instance for a given input size n that has the greatest cost.");

    }
}